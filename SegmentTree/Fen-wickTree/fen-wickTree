
# 펜윅 트리
# 홀수번 인덱스는 무조건 자기 자신의 누적합을 가진다
ex) 	array[1] = 1
	array[3] = 3
	array[5] = 5

# 짝수번 인덱스는 해당 인덱스를 2진수로 표현했을 때, 최하위 비트(가장 오른쪽에 있는 비트)까지의 연산 횟수다.
ex)	2 = 0010 즉 2번
	array[2] = array[1]+array[2]
	4 = 0100 즉 4번
	array[4] = array[1]+array[2]+array[3]+array[4]
	12 = 1100 즉 4번
	array[12] = array[12]+array[11]+array[10]+array[9]

홀수 또한 마찬가지로 최하위 비트만큼의 연산값을 가져서 자기 자신만큼만 연산이 된 것이다.
즉 짝수 홀수 모두 최하위 비트만큼의 연산을 가지게 된다.


# ※ 구현 방법
해당 인덱스의 최하위 비트를 계속 더해준다. 해당 비트들에 원래 배열 값이 모두 포함된다.
ex)	9 = 1001
	1001 + 0001 = 1010 = 10
	1010 + 0010 = 1100 = 12
	1100 + 0100 = 10000 = 16
즉 인덱스 9, 10, 12, 16에 array[9]의 값이 모두 포함된다.

# 공식
Index번호 = Index번호 + (Index번호 & -Index번호(2의 보수))
2의 보수란?
해당 비트를 전부 뒤집고 1을 더해준 값
ex) 9에 대한 2의 보수는
1001 -> 0110 + 0001 = 0111
index번호 & -index번호 = 1001 & 0111 -> 0001
즉 해당 식은 최하위 비트를 알려준다.

1001 + 0001 = 1010
즉 9는 10에게 영향을 준다.

마찬가지로 10을 예시로 들면
1010 & 0110 = 0010 즉 2의 이진수가 최하위 비트
1010 + 0010 = 1100 -> 12
즉 10은 12에 영향을 준다.	

# ※ 구현 수도 코드
for(int i = 1; i<=N; i++){
	update(i,array[i]);
}

void update(int idx, int val){
	while(idx<Ftree.length){
		Ftree[idx] = Ftree[idx] + val;
		idx = idx+(idx & -idx);
	}
}


# ※구간 연산
ex) A번부터 B번까지의 합을 구하라
-> 1~B까지의 누적합 - 1~A-1번까지의 누적합

추가로 

구현 코드
int sum(int idx){
	long a = 0;
	while(idx>0){
		a = a+Ftree[idx];
		idx = idx-(idx&-idx);
	}
	return a;
}

